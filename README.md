Реализованы все доп. задания.

Программа поддерживает следующие ключи: <br/>
-minLen N - задаёт минимальную длину слова длинной N <br/>
-useFilter - включает фильтрацию слов от цифр и символов <br/>

В программе проверяется работа для следующих вариантов: <br/>

1. read_file_common_map - потоки читают из файла и используют общий словарь <br/>
2. read_file_local_map - потоки читают из файла и используют локальные словари <br/>
3. read_vector_common_map - потоки читают из вектора и используют общий словарь <br/>
4. read_vector_local_map - потоки читают из вектора и используют локальные словари <br/>

============== Результаты для трёх файлов: ============== <br/>
The following files were found: <br/>
../books/The Great Gatsby.txt <br/>
../books/House Beautiful.txt <br/>
../books/History of Astronomy.txt <br/>

|                        | Кол-во <br/> потоков | Время в мкс при <br/>  -minLen 4 <br/>-useFilter 0 | Время в мкс при <br/> -minLen 4 <br/>-useFilter 1 |
|------------------------|:--------------------:|:--------------------------------------------------:|:-------------------------------------------------:|
| read_file_common_map   |          1           |                       21408                        |                      3514594                      |
| read_file_common_map   |          32          |                       71111                        |                      255515                       |
| read_file_local_map    |          1           |                       25361                        |                      3507678                      |
| read_file_local_map    |          32          |                       22209                        |                      264970                       |
| read_vector_common_map |          1           |                       30076                        |                      3487087                      |
| read_vector_common_map |          32          |                       114518                       |                      276282                       |
| read_vector_local_map  |          1           |                       30844                        |                      3490974                      |
| read_vector_local_map  |          32          |                       18753                        |                      271624                       |

## Выводы:

1. Чтение из файла в потоках быстрее, чем из вектора, который нужно ещё подготовить
2. Без нагрузки общий словарь медленнее в многопоточном режиме
3. При нагрузке общий словарь быстрее в многопоточном режиме
4. Локальные словари всегда быстрее в многопоточном режиме
5. При нагрузке в многопоточном режиме общий словарь и локальные примерно равны

# Обнаруженные проблемы

## 1 Очистка слов от цифр и символов

Задача: реализовать одновременную фильтрацию латиницы и кириллицы в regex.
std::regex(R"([^a-zA-Zа-яёА-ЯЁ ])") - вроде работает, но некоторые русские буквы портятся <br/>
Например <br/>
До: "Release привет: May@ 1, 2005 [eBook #8172]; - Most recently updated: $Сентябрь 8, 2014" <br/>
После: "Release п�иве� May eBook Most recently updated Сен�яб��" <br/>

## 2 Очистка слов от цифр и символов кроме апострофа

Задача: сохранить слова с апострофом, такие как: you’ve, didn’t, we’ve и т.д. <br/>
Если в regex разрешить символ апострофа, <br/>
std::regex(R"([^a-zA-Z’])") <br/>
то неправильно обрабатываются символы начала и конца цитаты “ и ”, которые встречаются в текстах <br/>

До: “just you’ve” “didn’t” “we’ve” <br/>
После: �just you’ve� �didn’t� �we’ve� <br/>

Хотел использовать lamda в std::transform для пропуска символов “ и ” <br/>
[](unsigned char ch) { return (std::string(1, ch) == "“" || std::string(1, ch) == "”") ? char() : ch;} <br/>
Однако, оказалось, что символы “ и ” состоят из нескольких частей. <br/>
При посимвольном выводе в консоль получил это <br/>
std::cout << *it << " "; <br/>
До: “you’ve” <br/>
После: � � � y o u � � � v e � � � <br/>

## 3 Скорость фильтрации слов

При использовании фильтра на основе std::regex_replace очень сильно увеличивается время выполнения <br/>
Например, при обработке трёх книг с флагом -minLen: 4 <br/>
Без фильтра: 18315 us <br/>
С фильтром: 3456347 us <br/>

## 4 Выход за границы вектора

Задача: перебрать элементы вектора с шагом `step`<br/>
Однако, условие `it != itEnd` не отрабатывает и итератор выходит за область памяти вектора <br/>
Как реализовать правильную проверку в данном случае?

```
std::vector<std::string> words;
auto it = std::begin(words);
auto itEnd = std::end(words);
for (; it != itEnd; std::advance(it, step)) {
    const std::string &word = *it;
}
```

## 5 Непоследовательная модификация и доступ к "count"

Почему возникает эта ошибка и как её исправлять?

```
void foo(const std::string &word, size_t count) {};

void test_error() {
  std::vector<std::string> words(10);
  size_t count = 0;
  foo(words[count], count++);
_________________________^____ 
Unsequenced modification and access to 'count'
}
```